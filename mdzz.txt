http://www.cnblogs.com/haippy/p/3237213.html
http://blog.csdn.net/yamingwu/article/details/47841689 std::thread
const int #define
char *a; char a[19]

C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。 
#ifndef A_H_
#define A_H_
...
#endif
这种方法不能防止编译器将文件包含两次，而只是让编译器忽略除第一次包含之外的所有内容！



z当在基类中创建了虚函数而没有在基类中对虚函数做具体的实现时将会产生LNK2001错误。解决办法是：①、将该虚函数定义为纯虚函数。②、在基类中对该虚函数做具体实现。

1、全缓冲
在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。
2、行缓冲
在这种情况下，当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是键盘输入数据。
3、不带缓冲
也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。

cout<<endl;
相当于
cout<<”\n” <<flush;


161212  人生第一次非故意越界  sprintf（） 给结构体中的一个成员赋值时直接给结构体赋值导致越界破坏了在它后面定义的vector 导致无复发使用vector的动态内存

16^1	16
16^2	256
16^3	4096
16^4	65536
16^5	1048576
16^6	16777216
16^7	268435456
16^8	4294967296

一个字节=8个0和1 
在txt里面输入一个a = 1个字节
8个字节=1b
1k=1024个字节
1m=1024^2个字节
1G=1024^3个字节
4G=1024^3*4个字节=4294967296个字节=34359738368个0和1
32位操作系统一个指针的大为4个字节=32个0和1  可以显示的最多不同值为4294967296
2*32=429496729  32位操作系统理论上只能控制4G内存 如果控制了8G没出错请大家一起膜拜微软的大神吧


系统调用开销大  使用fstream 代替文件描述符  每次读取字数不要太少

访问标准输出流必须同步：在任何时候，只有一个线程可以访问 std::cout。


类内静态函数定义

class test
{
	static int _a
	
};	

 int test::_a =1;


循环过程中消除容器中成员
for(auto i = a.begin();i!=a.end();)
{
	if(xxxxx)
	{
	  i=a.erase(i);
	}
	else
	{
	  ++i;
	{
}

复制文件 c++快100ms
#include<iostream>
#include<fstream>
#include<Windows.h>
using namespace std;
void woqu(char *a, char*b)
{
	ifstream fin("aa.PDF", ios::_Nocreate | ios::binary);
	ofstream fout("g.PDF", ios::binary);
	char c[1024];

	while (!fin.eof())
	{
		fin.read(c, 1024);
		fout.write(c, fin.gcount());
	}
	fin.close();
	fout.close();
}

void Tranfile(char* pszFileCopee, char* pszFileCoper)
{
	fstream fsCopee(pszFileCopee, ios::binary | ios::in);
	fstream fsCoper(pszFileCoper, ios::binary | ios::out);
	fsCoper << fsCopee.rdbuf();
}
int main()
{
	DWORD start, stop;

	FILE *op, *inp;
	fopen_s(&op, "aa.PDF", "rb");
	fopen_s(&inp, "c.PDF", "wb");

	void *buf;
	char c;
	start = GetTickCount();
	while (!feof(op))
	{
		//fread(&buf, 1, 1, op);
		//fwrite(&buf, 1, 1, inp);
		fread(&c, 1, 1, op);
		fwrite(&c, 1, 1, inp);
	}
	stop = GetTickCount();
	fclose(inp);
	fclose(op);
	printf("over");
	printf("c time: %lld ms\n", stop - start);
	
	start = GetTickCount();
	Tranfile("aa.PDF", "b.PDF");
	stop = GetTickCount();
	printf("c++ time: %lld ms\n", stop - start);
	system("pause");


}



获取文件信息的方法

struct _sta buf;
_stat("path",&buf);
buf.xx;

char a;  字符变量
char *a; 指向字符变量的指针
char *&a;指向字符变量的指针的引用


类内static 
#include<iostream>
#include<random>
#include"test.h"
using namespace std;
int main()
{
	test data1;
	cout << data1.data << endl;
	data1.data = 10;
	test data2;
	cout << data2.data << endl;
	change();

	test data3;
	cout << data3.data << endl;
	cin.get();
}

1 5 10


虚函数如果拥有默认实参 vs2013
基类使用基类的默认实参
派生的使用派生的默认实参
基类绑定派生使用基类实参


#include <stdio.h>  
#include <time.h>  
int main()  
{  
    time_t timep;  
    struct tm *p;  
    time(&timep);  
    p =localltime(&timep); //此函数获得的tm结构体的时间，是已经进行过时区转化为本地时间  
    //p = gmtime(&timep); //把日期和时间转换为格林威治(GMT)时间的函数  
  
    printf("Year:  %d\n", 1900+p->tm_year);  
    printf("Month:  %d\n", 1+p->tm_mon);  
    printf("Day:  %d\n", p->tm_mday);  
    printf("Hour:  %d\n", p->tm_hour);  
    printf("Minute:  %d\n", p->tm_min);  
    printf("Second:  %d\n",  p->tm_sec);  
    printf("Weekday:  %d\n", p->tm_wday);  
    printf("Days:  %d\n", p->tm_yday);  
    printf("Isdst:  %d\n", p->tm_isdst);  
} 
f:
完整路径 +数字
c:
解析 map 路径 文件名
返回选中文件路径路径
f:
判断文件还是文件加
文件返回信息 是文件
文件夹继续查询
返回完整路径+数字
c:
选中点击下载
f:
文件启动文件发送
文件夹启动冻文件夹发送

所有消息同一个报文
使用N个标识

发送文件一个线程
接收文件一个线程
界面一个线程//定时器在这
opendds一个线程 //接收消息自己创建的线程显示和界面一个线程


在terminal中使用输入法输入
terminal根据字符编码转换成二进制流
二进制流通过MySQL客户端传输到MySQL Server
Server通过character-set-client解码
判断character-set-client和目标表的charset是否一致
如果不一致则进行一次从client-charset到table-charset的一次字符编码转换
将转换后的字符编码二进制流存入文件中

从文件读出二进制数据流
用表字符集编码进行解码
将数据转换为character-set-client的编码
使用character-set-client编码为二进制流
Server通过网络传输到远端client
client通过bash配置的字符编码展示查询结果


无签名 utf8 fromutf8送到界面
char buf[1024];
sprintf(buf, "insert into test values(\"%s\",15)",line->text().toUtf8().data());

学号 姓名 学期 科目 成绩 补考成绩


this->setWindowFlags(Qt::FramelessWindowHint);
删除界面外框	
this->setWindowModality(Qt::ApplicationModal);
没有父类 设置模态

//GBK\> QString  
QString str = QString::fromLocal8Bit("新浪微博");  

 comboBox->clear();  
    qDebug()<<"======1======";  
    comboBox->addItems(QStringList()<<tr("竹外桃花三两枝")<<tr("春江水暖鸭先知")  
                       <<tr("蒌蒿满地芦芽短")<<tr("正是河豚欲上时"));  

void QComboBox::currentIndexChanged(const QString &text)

发生事件  创建事件对象  事件对象给当前窗口的父的QObject的event()函数  分发 事件过滤 mouseMoveEvent((QMouseEvent*)event);
类似函数接收 我们可以重写这个函数



获取系统时间
	char buf[1024];
	system_clock::time_point p = system_clock::now();
	std::time_t t = system_clock::to_time_t(p);
	ctime_s(buf, sizeof(buf), &t);


计时
	auto t1 = system_clock::now();
	std::this_thread::sleep_for(std::chrono::seconds(5));
	auto t2 = system_clock::now();

	auto duration = std::chrono::duration_cast<microseconds>(t2-t1);

	std::cout << double(duration.count())*std::chrono::microseconds::period::num / std::chrono::microseconds::period::den << "秒" << std::endl;


dynamic_cast


modulw Demo {
	#pragma DCPS_DATA_TYPE "Demo::Pos"
	#pragma DCPS_DATA_KEY "Demo::Pos.pos_id"
	typedef sequence<octet> lala;
	struct Pos{
		lala wei;
	};
};




http://blog.csdn.net/liang19890820/article/details/50866096  label
http://blog.csdn.net/liang19890820/article/details/51154216  paintEvent

读取所有记录
关文件
显示
添加新的
写入


struct {
	char name[64];
	char msg[1024];	
};



确定下载 连另一个端口
发送路径
处理路径
发送文件夹

确认上传
s:
检查重名
无
添加set返回 同意信息
c


服务器接收完成 刷新目录



=0 文件名; =1 文件数据; =2 所有文件发送完毕 

=3 共享文件夹的文件列表(完整路径)
=4 希望得到的文件列表的文件夹路径
=5 希望下载的文件路径(文件还是文件夹服务器判断)


=6 发送到group的信息
=7 private 私聊的信息
=8 需要第一次获取文件列表
=9 登陆用户名
=10 上传文件

Visual Studio Ultimate 2013 KEY（密钥）：BWG7X-J98B3-W34RT-33B3R-JVYW9

Visual Studio Premium 2013 KEY（密钥）：FBJVC-3CMTX-D8DVP-RTQCT-92494

Visual Studio Professional 2013  KEY（密钥）： XDM3T-W3T3V-MGJWK-8BFVD-GVPKY

Team Foundation Server 2013 KEY（密钥）：MHG9J-HHHX9-WWPQP-D8T7H-7KCQG


https://dev.mysql.com/downloads/mysql/

QTimer::singleShot(0, qApp, SLOT(quit())); //在构造函数中退出程序


///
https://wenku.baidu.com/view/50d36c665ef7ba0d4a733bcc.html
http://blog.csdn.net/liuligui5200/article/details/49888823
https://wenku.baidu.com/view/8600b8f5a5e9856a57126017.html

unicode  qt
utf-8    mysql
GB18030  数据传送 
utf-8    sqlit


目录
摘   要    i
Abstract    ii
1  绪论    1
1.1  课题背景    1
1.2  目的和意义    1
1.3  研究现状    1
2  系统分析    3
2.1  系统理论基础    3
2.1.1  C/S架构    3
2.1.2  TCP    3
2.1.3  Socket    4
2.1.4  QT编程框架    6
2.2  可行性研究    10
2.3  需求分析    11
2.4  系统运行环境    11
3  系统设计    12
3.1  系统结构设计    12
3.2  客户端服务器功能设计    
3.3  客户端设计    13
3.4  服务器端设计    14
3.5  群聊和私聊模块的设计    16
4  程序描述与详细描述    17
4.1  服务器端验证客户端的登录信息    17
4.1.1  功能及实现    17
4.1.2  技术概要    18
4.2  服务器端处理用户消息    20
4.2.1  功能及实现    20
4.2.2  技术概要    21
4.3  客户端读取服务器发送的数据    23
4.3.1  功能及实现    23
4.3.2  技术概要    25
4.4客户端用户列表的更新    25
5  系统实现    27
5.1  登录模块设计    27
5.2  注册模块设计    28
5.3  群聊模块设计    29
5.4  私聊模块设计    32
结论    34 
参考文献    35
致谢    36 〖

目录
 第1章 绪论 .................................................................................................................. 2
1.1选题背景 ........................................................................................................... 2
1.2目的和意义 ....................................................................................................... 2
 
第2章 系统概况 .......................................................................................................... 3
2.1系统主要功能 ................................................................................................... 3 
2.2系统所用技术 ................................................................................................... 3
2.2.1 Java技术 ............................................................................................. 3
2.2.2 TCP/IP协议 ......................................................................................... 4 
2.2.3 JMF使用RTP协议 ............................................................................... 4 
2.2.4 Mysql数据库 ....................................................................................... 4 
2.3系统运行环境 ................................................................................................... 4

 第3章 系统分析 .......................................................................................................... 5 
3.1关于系统分析 .................................................................................................. 5 
3.1.1可行性分析 ........................................................................................... 5 
3.2系统功能分析 ................................................................................................... 5 
3.2.1客户端功能分析 ................................................................................... 5 
3.2.2 服务器功能分析 .................................................................................. 6
3.3系统流程图 ....................................................................................................... 6

 第4章 系统设计 .......................................................................................................... 8 
4.1数据库表设计 .................................................................................................. 8 
4.2 自定义XMPP协议 ........................................................................................... 8 
第5章 系统实现 ........................................................................................................ 10 
 5.1 客户端实现 ................................................................................................... 10 
 5.1.1 登录界面 ............................................................................................ 10 
5.1.2 用户列表界面 .................................................................................... 13 
5.1.3 聊天窗口及视频界面 ........................................................................ 15
 5.2 服务器端实现 ................................................................................................ 20 
 5.2.1 服务器界面 ........................................................................................ 20 
 第6章 结束语 ............................................................................................................ 21
 参考文献 ...................................................................................................................... 22

qt 介绍
boost 介绍
   boost文件库洁儿少
   boost网络库介绍

技术分析

以包为单位  {  http://blog.csdn.net/zhaoforyou/article/details/53590096  一次发很多 不拉不拉}


发送文件实现{分块发送}    多个三方库的协调使用 更加深刻的理解了异步的概念

尽可能的使用异步

多线程 
线程简介
为何使用线程 阻塞界面
使用qt线程
 不支持别的线程操作界面线程
qt线程使用举例

外观设计

功能实现
 群聊
 私聊
 登陆
 切换皮肤
 浏览文件夹
 下载文件或文件夹



http://blog.sina.com.cn/s/blog_a6fb6cc90101eoop.html  阴影
http://blog.sina.com.cn/s/blog_a6fb6cc90101au8r.html  无边框
加一个 groupbox 给他阴影 

5.2 完善程序  加入sqlite 桌面图标 注册软件  去边框

5.3 摘要 技术介绍  完成目录  健壮性(makeshared  断线)

mainLayout->setMargin(30);  //表示控件与窗体的左右边距
mainLayout->setSpacing(40); //表示各个控件之间的上下间距

加密通讯 可以移植
自己做一个通讯 使用qt boost c++

目录
摘   要    i
Abstract    ii
1  绪论    1
1.1 背景
1.2 目的意义

2 系统分析
2.1关键技术介绍
c++！！！
2.1qt
2.2boost
2.3mysql
2.4sqlite
2.1环境介绍

3   需求分析 https://wenku.baidu.com/view/f4f86bfe81c758f5f61f6744.html
3.1 功能需求
3.2 性能需求

4. 技术分析
   多线程 

5  系统设计       描述一下可以做什么 画个图讲解
   数据包的设计   发送文件实现{分块发送}    多个三方库的协调使用 更加深刻的理解了异步的概念
   注册器设计
   登陆器设计
   聊天室设计
   下载器
   服务器设计
   外观设计
   健壮性

6  系统实现     描述怎么实现的 上代码
   登录器功能实现
   聊天功能实现
   浏览共享目录功能实现
   下载功能实现
结束语